{"title":"淘七淘八","description":"一些记录","language":"zh-CN","link":"//ataotao.github.io","pubDate":"Tue, 28 Feb 2017 01:09:24 GMT","lastBuildDate":"Tue, 28 Feb 2017 01:17:50 GMT","generator":"hexo-generator-json-feed","webMaster":"Ataotao","items":[{"title":"一些常用的git命令","link":"//ataotao.github.io/2017/02/28/一些常用的git命令/","description":"查看所有分支的详细日志git log --all --decorate --graph 它用线段表示分支的合并情况，还能看到标签： * commit ca0fd229e12d51a6429e6a91a094063bbc00ea56 (HEAD -&gt; master, origin/master, origin/HEAD) | Author: Geoffrey Booth &lt;webmaster@geoffreybooth.com&gt; | Date: Wed Feb 22 10:53:09 2017 -0800 | | Update v2 NPM installation instructions | * commit a9bd53d77f075953170a820615b627ddeeb85ed0 |\\ Merge: 91e3f72 f8ce1a8 | | Author: Jeremy Ashkenas &lt;jashkenas@gmail.com&gt; | | Date: Wed Feb 22 13:16:44 2017 -0500 | | | | Merge pull request #4448 from GeoffreyBooth/2-docs-on-master | | | | 2 docs on master | | | * commit f8ce1a8183f53a13c5bd14039654e0860c617dbd | | Author: Geoffrey &lt;webmaster@geoffreybooth.com&gt; | | Date: Tue Feb 21 20:58:31 2017 -0800 | | | | Teaser for CoffeeScript 2, link to 2 docs | | | * commit cee1076e1d459b9aeeca735a2817410ef0a28bf0 |/ Author: Geoffrey Booth &lt;webmaster@geoffreybooth.com&gt; 恢复一个文件git checkout &lt;file-path&gt; 清除工作目录中所有更改git reset --hard &amp;&amp; git clean -df 完全恢复工作目录git reset --hard &amp;&amp; git clean -dfx 它会使工作目录恢复成“全新”状态，即：刚clone之后的状态。 注意，它会清除所有的 ignored files。 （优雅地）回滚到原来的git revert -n &lt;commit&gt;..HEAD 然后再commit即可。 这和 git reset 以及rebase都不同，它不修改历史（不删除原来的commit），而是用新的commit来抵消。这是很好的方式，大多数情况下都最好用revert来撤销。 姑且把它称之为“软回滚”吧。 （强硬地）回滚到原来的git reset --hard &lt;commit&gt; 它会把HEAD指向这个commit，所以相当于把之后的commit全“删”了（不过并没真正删除，只有在定期的垃圾回收时刻才真正删除）。 不建议这样做。历史应该尽量保留，除非里面有敏感信息。 删除早期的commit以节省（远程或本地）空间git rebase -i --root 几年以前的commits，你可能想把它们都删除了（不建议，但是如果有个大文件在里面占据了很大容量，而现在没有这个文件了，那这些commits就是个包袱）。这个方法不但会删掉commits，还会改变之后所有commits的hash值，所以请慎用！ 运行后，会出来一编辑器，列出从第一个commit开始的所有commits，你只要把pick改成s，这个commit就会被“挤”掉（合并到上一个commit中）。我们举个例子，当运行此命令后，出现： pick bbb2b0b initpick 8ec6fb8 aaapick a1d84fc bbbpick b36a6da ccc你想删除第二个和第三个commit（也就是把它们都合并到第一个commit中），那就改成这样（千万不可直接删除行，否则可能会导致丢失不想删除的文件）： pick bbb2b0b inits 8ec6fb8 aaas a1d84fc bbbpick b36a6da ccc保存退出后，在最后还会出现一编辑器，是用来输入这个合并后的 commit message 的。 不过这还无法立即释放本地空间，如果要立即释放，要把所有东西从reflog里删除： git reflog expire --all --expire=now 然后再清理： git gc --prune=all 清空reflog和清理的步骤可以不做，push的时候远程仓库会自动删除这些已被删除的commit，然后别人clone或pull的时候也就不会下载这些多余文件了。 push的时候要这样： push -f 否则远程计算机会拒绝。因为我们已经修改或删除了已被push的commit，所以必须强制，才能让远程计算机也修改或删除这些commit。 列出变动的文件，但不包括详细内容git diff --name-status git diff --name-status &lt;commit&gt; &lt;commit&gt; 当变化很大，详细内容有无数行的时候，就很好用。 显示某个commit中某个文件的内容git show &lt;commit&gt;:&lt;path&gt; 例如 git show f6f207a:README.txt。 显示某个commit的更改git show &lt;commit&gt; git show --name-status &lt;commit&gt; 和diff非常相似，但命令更简洁些。 打包备份git bundle create &lt;backup-file-path&gt; --all 例如： git bundle create /backups/project1.bundle --all Git就会在/backups目录下生成project1.bundle文件，里面包含着.git目录下的一切被引用的对象，包括所有commit、标签、分支。这个文件是压缩的，非常小。你可以定期备份，当要还原的时候，只要clone即可： git clone /backups/project1.bundle project1 （完） 原文链接：https://zhanzhenzhen.github.io/2017_02_26/ 在github上建立gh-pages分支 为什么要建立gh-pages分支呢，因为github项目的静态页面解析需要这个名字的分支 //进入到你想要上传的文件夹下： cd text //git初始化 git init //创建gh-pages分支 git checkout –orphan gh-pages //添加文件到暂存区 git add . //添加信息 git commit -m “This is add message” //或者不写上面的git add .直接写 git commit -a -m \\”First pages commit\\”这个-a参数我查了之后说是对git add .的替代，但我不建议大家使用。 //添加仓库 git remote add origin git@github.com:username/project.git //部署你的项目到github git push origin gh-pages git命令//查看分支 git branch git branch -a //本地分支 git branch -r //远程分支 //建立分支 git branch 分支名 //切换分支 git checkout 分支名 //拉取 git pull git pull origin gh-pages git pull origin master //提交 git commit -m &quot;This is add message&quot; //推送 git push origin gh-pages git push origin master //add 全部 git add -A //git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 //git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add --update的缩写） //git add -A ：是上面两个功能的合集（git add --all的缩写） //本地的同步成远程的文件 git reset --hard origin //恢复某个文件 git checkout xxx.js","pubDate":"Tue, 28 Feb 2017 01:09:24 GMT","guid":"//ataotao.github.io/2017/02/28/一些常用的git命令/","category":"git"},{"title":"Javascript递归方式完美实现对象、数组深拷贝","link":"//ataotao.github.io/2017/02/09/javascript-deepClone/","description":"对象拷贝方式有很多种，但是如何能够不抛弃对象的constructor，而且相互对象的引用也会完整copy，不受影响，请看下面代码：深拷贝：对于深拷贝，针对成员变量存在指针的情况，不仅仅是简单的指针赋值，而是重新分配内存空间浅拷贝：只是拷贝了指针，使得两个指针指向同一个地址 知乎上有一个答案，这个方法可以拷贝对象和数组 123456789101112131415var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== 'object')&#123; return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === 'object' ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;; 这个方法遇到环或者是其他类型的数据就咯屁了，网上大部分深克隆的答案都没考虑循环引用问题以及不能toJSON的对象问题。自虐一下，放出一个完美方案，虽然某些类型不太可能遇到，采用这方案更加不容易出错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//完美解决方案var http = require('http');function deepClone(initialObj, finalObj) &#123; return _deepClone(initialObj, finalObj, &#123; k: [], v: [] &#125;);&#125;function _deepClone(initialObj, finalObj, conflict) &#123; var i; if (initialObj &amp;&amp; typeof initialObj === \"object\" &amp;&amp; (i = [Object, Array].indexOf(initialObj.constructor)) != -1) &#123; if (!finalObj) &#123; finalObj = initialObj.constructor === Array ? [] : &#123;&#125;; &#125; if (conflict) &#123; i = conflict.k.indexOf(initialObj); if (i != -1) &#123; return conflict.v[i]; &#125; conflict.k.push(initialObj); conflict.v.push(finalObj); &#125; for (var key in initialObj) &#123; finalObj[key] = _deepClone(initialObj[key], finalObj[key], conflict); &#125; return finalObj; &#125; return initialObj;&#125;//测试数据var a = &#123; \"n\": 1&#125;;a.x = a; //环引用var b = deepClone(a);console.log(b, b.x === b); //查看拷贝对象，x属性为环引用，一直循环//各种不同类型数据拷贝console.log(deepClone(1)); console.log(deepClone(new Date())); console.log(deepClone(/regex/i));console.log(deepClone(false));console.log(deepClone(undefined));//测试数据 end","pubDate":"Thu, 09 Feb 2017 01:03:12 GMT","guid":"//ataotao.github.io/2017/02/09/javascript-deepClone/","category":"Javascript"},{"title":"Hello World","link":"//ataotao.github.io/2017/02/08/hello-world/","description":"新创立了hexo-site","pubDate":"Wed, 08 Feb 2017 06:48:40 GMT","guid":"//ataotao.github.io/2017/02/08/hello-world/","category":"随笔"}]}