{"title":"淘七淘八","description":"一些记录","language":"zh-CN","link":"//ataotao.github.io","pubDate":"Sat, 17 Nov 2018 03:57:00 GMT","lastBuildDate":"Sat, 17 Nov 2018 04:02:57 GMT","generator":"hexo-generator-json-feed","webMaster":"Ataotao","items":[{"title":"svg转base64，svg, png, jpeg","link":"//ataotao.github.io/2018/11/17/svg转base64/","description":"###svg转换为base64，文件格式会变大, 浏览器解码也会消耗一定的资源，不建议使用，但是有需要的时候，可以参见下面方式进行转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;svgAsHtml&lt;/title&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/d3/3.5.17/d3.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;svg width=\"300\" height=\"170\" class=\"mysvg\" viewbox=\"0 0 300 170\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;path d=\"M100 10 L50 60 L150 60 Z\" stroke=\"#FB716D\" stroke-width=\"3\" fill=\"#FBA28A\" /&gt; &lt;rect x=\"55\" y=\"61\" width=\"90\" height=\"100\" fill=\"#F3C392\"&gt;&lt;/rect&gt; &lt;rect x=\"85\" y=\"97\" width=\"30\" height=\"30\" stroke=\"#f6f6f6\" stroke-width=\"3\" fill=\"#B2DBCB\" /&gt; &lt;line x1=\"85\" x2=\"115\" y1=\"112\" y2=\"112\" stroke=\"#f6f6f6\" stroke-width=\"3\" fill=\"transparent\" /&gt; &lt;line x1=\"100\" x2=\"100\" y1=\"97\" y2=\"127\" stroke=\"#f6f6f6\" stroke-width=\"3\" fill=\"transparent\" /&gt; &lt;g transform=\"translate(150,-18)\"&gt; &lt;path d=\"M 30 160 A 30 35, 0, 1, 1, 60 160 L 45 160 Z\" fill=\"#7ACB9E\"&gt;&lt;/path&gt; &lt;rect x=\"40\" y=\"160\" width=\"10\" height=\"22\" fill=\"#EBBEA6\" /&gt; &lt;/g&gt; &lt;g transform=\"translate(187,-18)\"&gt; &lt;path d=\"M70 100 L40 160 L100 160 Z\" fill=\"#7ACB9E\" /&gt; &lt;rect x=\"65\" y=\"160\" width=\"10\" height=\"22\" fill=\"#EBBEA6\" /&gt; &lt;/g&gt;&lt;/svg&gt;&lt;script type=\"text/javascript\"&gt; var mySvg = document.querySelector(\".mysvg\"); var svgCon = mySvg.outerHTML; //svg转base64; var href = 'data:image/svg+xml;base64,' + window.btoa(unescape(encodeURIComponent(svgCon))); var image = new Image(); image.src = href; //添加svg转base64格式的图片 var svgImg = document.createElement('img'); svgImg.src = href; document.body.appendChild(svgImg) //下载svg图片 var svgLink = document.createElement('a'); svgLink.download = \"image.svg\"; svgLink.href = href; svgLink.innerHTML = '下载svg图片' document.body.appendChild(svgLink); image.onload = function () &#123; var canvas = document.createElement('canvas'); canvas.width = image.width; canvas.height = image.height; var context = canvas.getContext('2d'); context.drawImage(image, 0, 0); //svg转png的base64编码; var imgDataUri = canvas.toDataURL('image/png'); console.log(imgDataUri); //添加svg转base64格式的png图片 var pngImg = document.createElement('img'); pngImg.src = imgDataUri; document.body.appendChild(pngImg) //下载png图片 var a = document.createElement('a'); a.download = \"image.png\"; a.href = imgDataUri; a.innerHTML = '下载png图片' document.body.appendChild(a); //svg转jpg的base64编码; var jpgDataUri = canvas.toDataURL('image/jpeg', 1); console.log(jpgDataUri) //添加svg转base64格式的jpg图片 var jpgImg = document.createElement('img'); jpgImg.src = jpgDataUri; document.body.appendChild(jpgImg) //下载jpg图片 var a = document.createElement('a'); a.download = \"image.jpeg\"; a.href = jpgDataUri; a.innerHTML = '下载jpg图片' document.body.appendChild(a); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","pubDate":"Sat, 17 Nov 2018 03:57:00 GMT","guid":"//ataotao.github.io/2018/11/17/svg转base64/","category":"Javascript"},{"title":"一些使 JavaScript 更加简洁的小技巧","link":"//ataotao.github.io/2018/11/07/一些使-JavaScript-更加简洁的小技巧/","description":"一些使 JavaScript 更加简洁的小技巧1.清空或截断数组在不重新给数组赋值的情况下，清空或截断数组的最简单方法是更改​​其 length 属性值： 12345678const arr = [11, 22, 33, 44, 55, 66];// truncantingarr.length = 3;console.log(arr); //=&gt; [11, 22, 33]// clearingarr.length = 0;console.log(arr); //=&gt; []console.log(arr[2]); //=&gt; undefined 2.使用对象解构(destructuring)模拟命名参数当您需要将一组可选变量传递给某个函数时，你很可能已经在使用配置对象了，如下所示： 1234567doSomething(&#123; foo: 'Hello', bar: 'Hey!', baz: 42 &#125;);function doSomething(config) &#123; const foo = config.foo !== undefined ? config.foo : 'Hi'; const bar = config.bar !== undefined ? config.bar : 'Yo!'; const baz = config.baz !== undefined ? config.baz : 13; // ...&#125; 这是一个古老但有效的模式，它试图在 JavaScript 中模拟命名参数。 函数调用看起来很好。 另一方面，配置对象处理逻辑不必要地冗长。 使用ES2015 对象解构，您可以绕过这个缺点： 123function doSomething(&#123; foo = 'Hi', bar = 'Yo!', baz = 13 &#125;) &#123; // ...&#125; 如果你需要使配置对象也可选，也很简单： 123function doSomething(&#123; foo = 'Hi', bar = 'Yo!', baz = 13 &#125; = &#123;&#125;) &#123; // ...&#125; 3.使用对象解构来处理数组可以使用对象解构将数组项分配给各个变量： 12const csvFileLine = '1997,John Doe,US,john@doe.com,New York';const &#123; 2: country, 4: state &#125; = csvFileLine.split(','); 4.switch 语句中使用范围值注意：经过一番思考后，我决定将这个技巧与本文中的其他技巧区分开来。 这不是一种节省时间的技术，不适用于现实生活中的代码。 请记住：“If”语句在这种情况下总是更好。 与这篇文章中的其他提示不同，它更像是一种好奇探索而不是真正使用的东西。 但是，出于历史原因，我会在本文中保留它。 这是在 switch 语句中使用范围值的简单技巧： 1234567891011function getWaterState(tempInCelsius) &#123; let state; switch (true) &#123; case (tempInCelsius &lt; = 0): state = 'Solid'; break; case (tempInCelsius &gt; 0 &amp;&amp; tempInCelsius &lt; 100): state = 'Liquid'; break; default: state = 'Gas'; &#125; return state;&#125; 5.使用 async/await 来 await多个async函数可以使用 Promise.all 来 await 多个 async（异步）函数。 1await Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()]) 6.创建纯(pure)对象您可以创建一个 100％ 纯对象，它不会从 Object 继承任何属性或方法（例如，constructor，toString() 等）。 12345const pureObject = Object.create(null);console.log(pureObject); //=&gt; &#123;&#125;console.log(pureObject.constructor); //=&gt; undefinedconsole.log(pureObject.toString); //=&gt; undefinedconsole.log(pureObject.hasOwnProperty); //=&gt; undefined 7.格式化JSON代码JSON.stringify 不仅可以简单地将对象转化为字符串。你也可以用它来格式化JSON输出： 1234567891011121314151617181920const obj = &#123; foo: &#123; bar: [11, 22, 33, 44], baz: &#123; bing: true, boom: 'Hello' &#125; &#125; &#125;;// The third parameter is the number of spaces used to // beautify the JSON output.JSON.stringify(obj, null, 4); // =&gt;\"&#123;// =&gt; \"foo\": &#123;// =&gt; \"bar\": [// =&gt; 11,// =&gt; 22,// =&gt; 33,// =&gt; 44// =&gt; ],// =&gt; \"baz\": &#123;// =&gt; \"bing\": true,// =&gt; \"boom\": \"Hello\"// =&gt; &#125;// =&gt; &#125;// =&gt;&#125;\" 8.从数组中删除重复元素(数组去重)通过使用通过使用集合语法和 Spread(展开)运算符，您可以轻松地从数组中删除重复项： 123const removeDuplicateItems = arr =&gt; [...new Set(arr)];removeDuplicateItems([42, 'foo', 42, 'foo', true, true]);//=&gt; [42, \"foo\", true] 9.平铺多维数组使用 Spread(展开)，可以很容易去平铺嵌套多维数组： 12const arr = [11, [22, 33], [44, 55], 66];const flatArr = [].concat(...arr); //=&gt; [11, 22, 33, 44, 55, 66] 可惜，上面的方法仅仅适用于二维数组。不过，通过递归，我们可以平铺任意维度的嵌套数组。 12345678unction flattenArray(arr) &#123;const flattened = [].concat(...arr);return flattened.some(item =&gt; Array.isArray(item)) ? flattenArray(flattened) : flattened;&#125;const arr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];const flatArr = flattenArray(arr); //=&gt; [11, 22, 33, 44, 55, 66, 77, 88, 99] 就是这些啦！我希望这些巧妙的小技巧可以帮助你编写更好，更漂亮的 JavaScript 。 via: css88.com英文原文：https://medium.freecodecamp.org/9-neat-javascript-tricks-e2742f2735c3","pubDate":"Wed, 07 Nov 2018 01:51:17 GMT","guid":"//ataotao.github.io/2018/11/07/一些使-JavaScript-更加简洁的小技巧/","category":"Javascript"},{"title":"React组件状态的理解","link":"//ataotao.github.io/2018/11/07/pageReact组件状态理解/","description":"有状态的组件没有渲染，有渲染的组件没有状态 “有状态的组件没有渲染”：包含实际业务状态的组件不应该进行视图的渲染，而是应该将实际业务状态传递给子孙组件，让子孙组件来进行视图渲染； “有渲染的组件没有状态”：能够进行视图渲染的组件，不要包含实际的业务状态，而是通过接受父辈的参数来进行渲染；这样的话，有渲染的组件没有实际的业务状态，就与实际的业务解耦了，能够更好的服务于其他的有状态的组件，实现组件的复用。 via： 热爱 对React Hooks的一些思考","pubDate":"Wed, 07 Nov 2018 01:28:27 GMT","guid":"//ataotao.github.io/2018/11/07/pageReact组件状态理解/","category":"React"},{"title":"将多维数组递归降维成一维数组的巧妙实现","link":"//ataotao.github.io/2018/10/25/将多维数组递归降维成一维数组的巧妙实现/","description":"将多维数组递归降维成一维数组的巧妙实现思路：只要为数组，就递归调用函数通过reduce展开 12345const ﬂattenDeep = (arr) =&gt; Array.isArray(arr) ? arr.reduce((a, b) =&gt; [...ﬂattenDeep(a), ...ﬂattenDeep(b)], []) : [arr];const data = ﬂattenDeep([1, [[2], [3, [4]], 5]]);console.log(data);","pubDate":"Wed, 24 Oct 2018 23:10:01 GMT","guid":"//ataotao.github.io/2018/10/25/将多维数组递归降维成一维数组的巧妙实现/","category":"Javascript"},{"title":"精准计算浮点数原生解决方法","link":"//ataotao.github.io/2018/10/25/精准计算浮点数原生解决方法/","description":"精准计算浮点数原生解决方法原生解决0.1 + 0.2 = 0.30000000000000004的方式 1parseFloat((0.1 + 0.2).toFixed(10))","pubDate":"Wed, 24 Oct 2018 23:01:00 GMT","guid":"//ataotao.github.io/2018/10/25/精准计算浮点数原生解决方法/","category":"Javascript"},{"title":"通过MessageChannel实现深拷贝","link":"//ataotao.github.io/2018/10/24/JavaScript 检测是不是手机浏览器/","description":"如果拷贝的对象不包含函数，可以使用 MessageChannel来实现Channel Messaging API的Channel Messaging接口允许我们创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据。 123456789101112131415161718192021222324const arr = ['arr'];const obj = &#123; a: 1, s: undefined, r: null, b: &#123; c: arr &#125;&#125;;function structuralClone(oldData, callback) &#123; const &#123; port1, port2 &#125; = new MessageChannel(); port2.onmessage = ev =&gt; callback(ev.data); port1.postMessage(oldData);&#125;// 注意该方法是异步的// 可以处理 undefned 和循环引用对象structuralClone(obj, function (newData) &#123; console.log('newData === obj', newData === obj, newData); // newData.b.c与arr的引用关系被解除了 console.log('newData.b.c === arr', newData.b.c === arr, newData.b.c); console.log('obj.b.c === arr', obj.b.c === arr, obj.b.c);&#125;);","pubDate":"Wed, 24 Oct 2018 09:32:00 GMT","guid":"//ataotao.github.io/2018/10/24/JavaScript 检测是不是手机浏览器/","category":"Javascript"},{"title":"React内联SVG背景图的实现","link":"//ataotao.github.io/2018/10/24/React内联SVG背景图的实现/","description":"内联SVG背景图像在React.js中的实现遇到一个需求，后台返回验证码是一个内联的svg字符串，如果通过 dangerouslySetInnerHTML 方式直接插入到页面，不方便调整尺寸; 背景图像的实现方式 12const captchaSvg = window.encodeURIComponent(captchaImg);&lt;div style=&#123;backgroundImage:`url(data:image/svg+xml;charset=UTF-8,$&#123;captchaSvg&#125;)`, backgroundSize: '100% 100%', width:200, height:50&#125; /&gt;","pubDate":"Wed, 24 Oct 2018 03:43:33 GMT","guid":"//ataotao.github.io/2018/10/24/React内联SVG背景图的实现/","category":"React"},{"title":"通过try catch模拟延迟获取未知对象的方法","link":"//ataotao.github.io/2017/06/24/模拟延迟获取初始化未知对象的方法/","description":"有时候一些初始化数据异步获取，当页面初始化完成，但是数据还未正常初始化，导致页面错误，可以用下面的简单递归方式获取 //模拟数据延迟 var a; setTimeout(function () { a = { name: 1, age: 2 }; }, 5000); //延迟5秒初始化数据 //递归自动执行 (function () { try { // a不是对象时会抛出错误 a.name; } catch (e) { //延迟再试一次~ setTimeout(arguments.callee, 50); return; } // 没有错误就表示数据获取正常 5秒后正常打印数据 console.log(a); })();","pubDate":"Sat, 24 Jun 2017 01:50:31 GMT","guid":"//ataotao.github.io/2017/06/24/模拟延迟获取初始化未知对象的方法/","category":"Javascript"},{"title":"NodeJs设置环境变量的几种方式","link":"//ataotao.github.io/2017/03/11/NodeJs设置环境变量的几种方式/","description":"方法一： 执行的时候设置1234npm start --production// app.jsconsole.log(process.env.NODE_ENV);production 方法二： package.json文件里面配置1234\"scripts\": &#123; \"start\": \"set NODE_ENV = development &amp;&amp; node ./bin/www\", \"dev\": \"set NODE_ENV = development &amp;&amp; node app\"&#125;,","pubDate":"Sat, 11 Mar 2017 01:24:56 GMT","guid":"//ataotao.github.io/2017/03/11/NodeJs设置环境变量的几种方式/","category":"Nodejs"},{"title":"Math对象技巧，Math.max，Math.min获取数组最大值和Math.random随机数","link":"//ataotao.github.io/2017/03/03/Math对象技巧，Math.max，Math.min获取数组最大值和Math.random随机数/","description":"Math对象技巧，Math.max，Math.min获取数组最大值和Math.random随机数#Math.max，Math.min 求最大值、最小值 //最大值 最小值 var max = Math.max(3, 54, 32, 16); console.log(max); //54 var min = Math.min(3, 54, 32, 16); console.log(min); //3 var values = [1, 2, 3, 4, 5, 6, 7, 8]; var arrMax = Math.max.apply(Math, values); var arrMin = Math.min.apply(Math, values); console.log(arrMax); //8 console.log(arrMin); //1 #Math.ceil Math.floor Math.round舍入方法 // 舍入方法 /* * Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数； * Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数； * Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课 */ console.log(Math.ceil(25.9)); //26 console.log(Math.ceil(25.5)); //26 console.log(Math.ceil(25.1)); //26 console.log(Math.round(25.9)); //26 console.log(Math.round(25.5)); //26 console.log(Math.round(25.1)); //25 console.log(Math.floor(25.9)); //25 console.log(Math.floor(25.5)); //25 console.log(Math.floor(25.1)); //25 #Math.random()随机数 // 套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。 //var 值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) //选择一个1到10 之间的数值 var num1 = Math.floor(Math.random() * 10 + 1); // 选择一个介于2 到10 之间的值 var num2 = Math.floor(Math.random() * 9 + 2); // 整合方法 function selectFrom(lowerValue, upperValue) { var choices = upperValue - lowerValue + 1; return Math.floor(Math.random() * choices + lowerValue); } var num = selectFrom(2, 10); console.log(num); // 介于 2 和10 之间（包括 2 和 10）的一个数值 #Math.random()应用 // 函数selectFrom()接受两个参数：应该返回的最小值和最大值。而用最大值减最小值再加1 得到了可能值的总数，然后它又把这些数值套用到了前面的公式中。 // 这样，通过调用selectFrom(2,10)就可以得到一个介于2 和10 之间（包括2 和10）的数值了。 // 利用这个函数，可以方便地从数组中随机取出一项 var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;]; var color = colors[selectFrom(0, colors.length - 1)]; console.log(color); // 可能是数组中包含的任何一个字符串","pubDate":"Fri, 03 Mar 2017 01:39:00 GMT","guid":"//ataotao.github.io/2017/03/03/Math对象技巧，Math.max，Math.min获取数组最大值和Math.random随机数/","category":"Javascript"},{"title":"一些常用的git命令","link":"//ataotao.github.io/2017/02/28/一些常用的git命令/","description":"查看所有分支的详细日志git log --all --decorate --graph 它用线段表示分支的合并情况，还能看到标签： * commit ca0fd229e12d51a6429e6a91a094063bbc00ea56 (HEAD -&gt; master, origin/master, origin/HEAD) | Author: Geoffrey Booth &lt;webmaster@geoffreybooth.com&gt; | Date: Wed Feb 22 10:53:09 2017 -0800 | | Update v2 NPM installation instructions | * commit a9bd53d77f075953170a820615b627ddeeb85ed0 |\\ Merge: 91e3f72 f8ce1a8 | | Author: Jeremy Ashkenas &lt;jashkenas@gmail.com&gt; | | Date: Wed Feb 22 13:16:44 2017 -0500 | | | | Merge pull request #4448 from GeoffreyBooth/2-docs-on-master | | | | 2 docs on master | | | * commit f8ce1a8183f53a13c5bd14039654e0860c617dbd | | Author: Geoffrey &lt;webmaster@geoffreybooth.com&gt; | | Date: Tue Feb 21 20:58:31 2017 -0800 | | | | Teaser for CoffeeScript 2, link to 2 docs | | | * commit cee1076e1d459b9aeeca735a2817410ef0a28bf0 |/ Author: Geoffrey Booth &lt;webmaster@geoffreybooth.com&gt; 恢复一个文件git checkout &lt;file-path&gt; 清除工作目录中所有更改git reset --hard &amp;&amp; git clean -df 完全恢复工作目录git reset --hard &amp;&amp; git clean -dfx 它会使工作目录恢复成“全新”状态，即：刚clone之后的状态。 注意，它会清除所有的 ignored files。 （优雅地）回滚到原来的git revert -n &lt;commit&gt;..HEAD 然后再commit即可。 这和 git reset 以及rebase都不同，它不修改历史（不删除原来的commit），而是用新的commit来抵消。这是很好的方式，大多数情况下都最好用revert来撤销。 姑且把它称之为“软回滚”吧。 （强硬地）回滚到原来的git reset --hard &lt;commit&gt; 它会把HEAD指向这个commit，所以相当于把之后的commit全“删”了（不过并没真正删除，只有在定期的垃圾回收时刻才真正删除）。 不建议这样做。历史应该尽量保留，除非里面有敏感信息。 删除早期的commit以节省（远程或本地）空间git rebase -i --root 几年以前的commits，你可能想把它们都删除了（不建议，但是如果有个大文件在里面占据了很大容量，而现在没有这个文件了，那这些commits就是个包袱）。这个方法不但会删掉commits，还会改变之后所有commits的hash值，所以请慎用！ 运行后，会出来一编辑器，列出从第一个commit开始的所有commits，你只要把pick改成s，这个commit就会被“挤”掉（合并到上一个commit中）。我们举个例子，当运行此命令后，出现： pick bbb2b0b initpick 8ec6fb8 aaapick a1d84fc bbbpick b36a6da ccc你想删除第二个和第三个commit（也就是把它们都合并到第一个commit中），那就改成这样（千万不可直接删除行，否则可能会导致丢失不想删除的文件）： pick bbb2b0b inits 8ec6fb8 aaas a1d84fc bbbpick b36a6da ccc保存退出后，在最后还会出现一编辑器，是用来输入这个合并后的 commit message 的。 不过这还无法立即释放本地空间，如果要立即释放，要把所有东西从reflog里删除： git reflog expire --all --expire=now 然后再清理： git gc --prune=all 清空reflog和清理的步骤可以不做，push的时候远程仓库会自动删除这些已被删除的commit，然后别人clone或pull的时候也就不会下载这些多余文件了。 push的时候要这样： push -f 否则远程计算机会拒绝。因为我们已经修改或删除了已被push的commit，所以必须强制，才能让远程计算机也修改或删除这些commit。 列出变动的文件，但不包括详细内容git diff --name-status git diff --name-status &lt;commit&gt; &lt;commit&gt; 当变化很大，详细内容有无数行的时候，就很好用。 显示某个commit中某个文件的内容git show &lt;commit&gt;:&lt;path&gt; 例如 git show f6f207a:README.txt。 显示某个commit的更改git show &lt;commit&gt; git show --name-status &lt;commit&gt; 和diff非常相似，但命令更简洁些。 打包备份git bundle create &lt;backup-file-path&gt; --all 例如： git bundle create /backups/project1.bundle --all Git就会在/backups目录下生成project1.bundle文件，里面包含着.git目录下的一切被引用的对象，包括所有commit、标签、分支。这个文件是压缩的，非常小。你可以定期备份，当要还原的时候，只要clone即可： git clone /backups/project1.bundle project1 （完） 原文链接：https://zhanzhenzhen.github.io/2017_02_26/ 在github上建立gh-pages分支 为什么要建立gh-pages分支呢，因为github项目的静态页面解析需要这个名字的分支 //进入到你想要上传的文件夹下： cd text //git初始化 git init //创建gh-pages分支 git checkout –orphan gh-pages //添加文件到暂存区 git add . //添加信息 git commit -m “This is add message” //或者不写上面的git add .直接写 git commit -a -m \\”First pages commit\\”这个-a参数我查了之后说是对git add .的替代，但我不建议大家使用。 //添加仓库 git remote add origin git@github.com:username/project.git //部署你的项目到github git push origin gh-pages git命令//查看分支 git branch git branch -a //本地分支 git branch -r //远程分支 //建立分支 git branch 分支名 //切换分支 git checkout 分支名 //拉取 git pull git pull origin gh-pages git pull origin master //提交 git commit -m &quot;This is add message&quot; //推送 git push origin gh-pages git push origin master //add 全部 git add -A //git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 //git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add --update的缩写） //git add -A ：是上面两个功能的合集（git add --all的缩写） //本地的同步成远程的文件 git reset --hard origin //恢复某个文件 git checkout xxx.js","pubDate":"Tue, 28 Feb 2017 01:09:24 GMT","guid":"//ataotao.github.io/2017/02/28/一些常用的git命令/","category":"git"},{"title":"Javascript递归方式完美实现对象、数组深拷贝","link":"//ataotao.github.io/2017/02/09/javascript-deepClone/","description":"对象拷贝方式有很多种，但是如何能够不抛弃对象的constructor，而且相互对象的引用也会完整copy，不受影响，请看下面代码：深拷贝：对于深拷贝，针对成员变量存在指针的情况，不仅仅是简单的指针赋值，而是重新分配内存空间浅拷贝：只是拷贝了指针，使得两个指针指向同一个地址 知乎上有一个答案，这个方法可以拷贝对象和数组 123456789101112131415var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== 'object')&#123; return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === 'object' ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;; 这个方法遇到环或者是其他类型的数据就咯屁了，网上大部分深克隆的答案都没考虑循环引用问题以及不能toJSON的对象问题。自虐一下，放出一个完美方案，虽然某些类型不太可能遇到，采用这方案更加不容易出错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//完美解决方案var http = require('http');function deepClone(initialObj, finalObj) &#123; return _deepClone(initialObj, finalObj, &#123; k: [], v: [] &#125;);&#125;function _deepClone(initialObj, finalObj, conflict) &#123; var i; if (initialObj &amp;&amp; typeof initialObj === \"object\" &amp;&amp; (i = [Object, Array].indexOf(initialObj.constructor)) != -1) &#123; if (!finalObj) &#123; finalObj = initialObj.constructor === Array ? [] : &#123;&#125;; &#125; if (conflict) &#123; i = conflict.k.indexOf(initialObj); if (i != -1) &#123; return conflict.v[i]; &#125; conflict.k.push(initialObj); conflict.v.push(finalObj); &#125; for (var key in initialObj) &#123; finalObj[key] = _deepClone(initialObj[key], finalObj[key], conflict); &#125; return finalObj; &#125; return initialObj;&#125;//测试数据var a = &#123; \"n\": 1&#125;;a.x = a; //环引用var b = deepClone(a);console.log(b, b.x === b); //查看拷贝对象，x属性为环引用，一直循环//各种不同类型数据拷贝console.log(deepClone(1)); console.log(deepClone(new Date())); console.log(deepClone(/regex/i));console.log(deepClone(false));console.log(deepClone(undefined));//测试数据 end","pubDate":"Thu, 09 Feb 2017 01:03:12 GMT","guid":"//ataotao.github.io/2017/02/09/javascript-deepClone/","category":"Javascript"},{"title":"Hello World","link":"//ataotao.github.io/2017/02/08/hello-world/","description":"新创立了hexo-site","pubDate":"Wed, 08 Feb 2017 06:48:40 GMT","guid":"//ataotao.github.io/2017/02/08/hello-world/","category":"随笔"}]}